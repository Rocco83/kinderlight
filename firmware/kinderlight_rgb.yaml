esphome:
  # this is the hostname, the mac_suffix will differentiate the device
  name: kinderlight-rgb
  friendly_name: KinderLight-RGB
  name_add_mac_suffix: true
  on_boot:
    priority: 600 # Run after sensors are initialized
    then:
      - lambda: |-
          // Restore the curve from Flash string to RAM vector
          std::string s = id(calib_storage);
          std::string delimiter = ",";
          size_t pos = 0;
          std::string token;
          int i = 0;

          ESP_LOGI("storage", "Restoring calibration curve: %s", s.c_str());

          // Parse CSV string
          while ((pos = s.find(delimiter)) != std::string::npos && i < 11) {
              token = s.substr(0, pos);
              id(calib_curve)[i] = strtof(token.c_str(), NULL);
              s.erase(0, pos + delimiter.length());
              i++;
          }
          // Handle the last value
          if (i < 11) {
             id(calib_curve)[i] = strtof(s.c_str(), NULL);
          }

esp32:
  board: esp32-c6-devkitm-1
  framework:
    type: esp-idf

# Enable logging via UART
logger:

# default HA integration, OTA updater and backup http web portal
api:
  # TODO increase the security
  # password: !secret device_password
  #encryption:
  #  key: "YOUR_ENCRYPTION_KEY"
  # 5m default delay. if no home assistant, then force reboot
  reboot_timeout: 0s

ota:
  - platform: esphome
  # TODO increase the security
  # password: !secret device_password
  # change to https://esphome.io/components/ota/http_request ?

wifi:
  # Read the wifi/pass from secrets.yaml and support 2 SSID
  networks:
  - ssid: !secret wifi_1_ssid
    password: !secret wifi_1_password
  - ssid: !secret wifi_2_ssid
    password: !secret wifi_2_password

# Web server for local diagnostics
web_server:
  port: 80
  version: 3

# I2C Bus for BH1750 sensor
i2c:
  sda: GPIO14 # 8th pin right
  scl: GPIO15 # 7th pin right
  #scan: true #
  id: i2c_bus_a

globals:
  # Working vector (RAM) - stores the offsets: 0%, 10%, ... 100%
  # Initialized with your measured deltas (Measured - 0.1 lux baseline)
  - id: calib_curve
    type: std::vector<float>
    initial_value: '{0.0, 0.0, 0.4, 1.0, 2.4, 4.7, 7.6, 11.8, 17.3, 23.9, 31.8}'

  # Persistent storage (Flash) - saves curve as CSV string
  - id: calib_storage
    type: std::string
    restore_value: true
    initial_value: '"0.0,0.0,0.4,1.0,2.4,4.7,7.6,11.8,17.3,23.9,31.8"'

  # Helper iterator for the calibration loop
  - id: calib_iterator
    type: int
    initial_value: '0'

script:
  - id: run_dynamic_calibration
    mode: restart

    # ADDED: Define all incoming parameters
    parameters:
      init_override: bool
      init_on: bool
      init_bri: float
      init_r: float
      init_g: float
      init_b: float

    then:
      - logger.log: "Starting Dynamic Calibration (11 steps)..."

      # Reset iterator and turn off light
      - globals.set:
          id: calib_iterator
          value: '0'
      - light.turn_off: kinderlight_rgb_light
      - delay: 3s

      # Measure Baseline (0%)
      - lambda: |-
          // Store baseline (ambient light)
          // We temporarily store the raw value in index 0
          float val = id(ambient_light).state;
          id(calib_curve)[0] = val;
          ESP_LOGI("calib", "Baseline: %.1f lx", val);

      # Loop steps 1 to 10 (10% - 100%)
      - repeat:
          count: 10
          then:
            - lambda: 'id(calib_iterator) += 1;'

            # Set brightness
            - light.turn_on:
                id: kinderlight_rgb_light
                brightness: !lambda 'return id(calib_iterator) / 10.0;'
                red: 100%
                green: 100%
                blue: 100%
                transition_length: 1s

            - delay: 3s # Wait for sensor

            # Measure and calculate Delta
            - lambda: |-
                int i = id(calib_iterator);
                float current_lux = id(ambient_light).state;
                float baseline = id(calib_curve)[0]; // Retrieve raw baseline

                // Calculate how much light the lamp is adding
                float delta = current_lux - baseline;
                if (delta < 0) delta = 0;

                if (i < 11) {
                  id(calib_curve)[i] = delta;
                  ESP_LOGI("calib", "Step %d: Delta %.1f", i, delta);
                }

      # Finish: Reset index 0 to 0.0 (baseline offset is always 0)
      - lambda: 'id(calib_curve)[0] = 0.0;'

      # Turn off light
      - light.turn_off: kinderlight_rgb_light

      # Serialize to CSV String and Save to Flash
      - lambda: |-
          std::string s = "";
          char buffer[10];
          for (int i = 0; i < 11; i++) {
             sprintf(buffer, "%.1f", id(calib_curve)[i]);
             s += buffer;
             if (i < 10) s += ",";
          }
          id(calib_storage) = s;
          ESP_LOGI("storage", "Saved to flash: %s", s.c_str());

      # We turn the light ON with the original values to overwrite the
      # "Calibration White" in the internal memory.
      - light.turn_on:
          id: kinderlight_rgb_light
          brightness: !lambda 'return init_bri;'
          red: !lambda 'return init_r;'
          green: !lambda 'return init_g;'
          blue: !lambda 'return init_b;'
          transition_length: 0s # Instant restore to minimize visual glitch

      # If it was originally OFF, we turn it OFF immediately.
      # The color memory is now correct (Red/Green etc) instead of White.
      - if:
          condition:
            lambda: 'return !init_on;'
          then:
            - light.turn_off:
                id: kinderlight_rgb_light
                transition_length: 0s

      - if:
          condition:
            lambda: 'return init_override;'
          then:
            - switch.turn_on: manual_override
          else:
            - switch.turn_off: manual_override

      - logger.log: "Calibration Complete. State and Data restored."

button:
  - platform: template
    name: "Clear Stored States"
    id: clear_states_button
    icon: "mdi:database-remove"
    entity_category: "config"
    on_press:
      then:
        - lambda: |-
            global_preferences->reset();
            ESP_LOGI("custom", "NVM Memory Cleared! Restarting...");
        - delay: 1s
        # This is the correct way to reboot via code
        - lambda: 'App.safe_reboot();'

  - platform: template
    name: "Run Calibration (Dark Room)"
    icon: "mdi:chart-bell-curve-cumulative"
    entity_category: "config"
    on_press:
      - script.execute:
          id: run_dynamic_calibration
          # 1. Capture Override Switch
          init_override: !lambda 'return id(manual_override).state;'
          # 2. Capture Light State (Physical ON/OFF)
          init_on: !lambda 'return id(kinderlight_rgb_light).current_values.is_on();'
          # 3. Capture STORED Brightness and Colors (Use remote_values!)
          # This gets the color setting even if the light is currently OFF
          init_bri: !lambda 'return id(kinderlight_rgb_light).remote_values.get_brightness();'
          init_r: !lambda 'return id(kinderlight_rgb_light).remote_values.get_red();'
          init_g: !lambda 'return id(kinderlight_rgb_light).remote_values.get_green();'
          init_b: !lambda 'return id(kinderlight_rgb_light).remote_values.get_blue();'

sensor:
  # Ambient light sensor
  - platform: bh1750
    name: "KinderLight Raw Ambient Light"
    id: ambient_light
    address: 0x23
    # target?
    #update_interval: 10s
    update_interval: 1s
    entity_category: "diagnostic"
    # needed to correct the lux in the room with the reading - eg filters in front of
    filters:
      # calculate the value - eg using a lux meter - and adapt the value read with the real one
      - multiply: 1.0

  - platform: template
    name: "KinderLight Real Lux"
    id: real_lux_sensor
    unit_of_measurement: "lx"
    device_class: illuminance
    accuracy_decimals: 1
    update_interval: 1s
    entity_category: "diagnostic"
    lambda: |-
      float current_lux = id(ambient_light).state;
      float offset = 0.0;

      // Logic moved here: Check if light is ON
      if (id(kinderlight_rgb_light).current_values.is_on()) {

        // 1. Get brightness
        float bri = id(kinderlight_rgb_light).current_values.get_brightness();

        // 2. Scale to array index space (0 to 10)
        float scaled = bri * 10.0;
        int idx = (int)scaled;
        if (idx >= 10) idx = 9;

        // 3. Interpolation
        float frac = scaled - (float)idx;
        float val_low = id(calib_curve)[idx];
        float val_high = id(calib_curve)[idx+1];

        offset = val_low + (val_high - val_low) * frac;
      }

      // Calculate Real Ambient
      float real_ambient = current_lux - offset;
      if (real_ambient < 0) real_ambient = 0;

      return real_ambient;

  - platform: wifi_signal
    name: "WiFi Signal dB"
    id: wifi_signal_db
    update_interval: 60s # Check every minute
    entity_category: "diagnostic"
    filters:
      - sliding_window_moving_average: # Smooth out data to prevent false triggers
          window_size: 3
          send_every: 1
    on_value:
      then:
        - if:
            condition:
              and:
                - wifi.connected:
                - lambda: 'return x < -80;' # Trigger if signal is worse than -80dB
            then:
              - logger.log: "WiFi Signal is below -80dB. Forcing scan for better BSSID..."
              # There is no "roam" command, so we toggle WiFi to force a new scan/connect
              - wifi.disable:
              - delay: 2s
              - wifi.enable:



# PWM outputs for RGB LED
output:
  - platform: ledc
    id: pwm_red
    pin: GPIO1
    frequency: 1000Hz
  - platform: ledc
    id: pwm_green
    pin: GPIO2
    frequency: 1000Hz
  - platform: ledc
    id: pwm_blue
    pin: GPIO3
    frequency: 1000Hz

# RGB Light entity
light:
  - platform: rgb
    name: "KinderLight RGB"
    icon: "mdi:led-outline"
    red: pwm_red
    green: pwm_green
    blue: pwm_blue
    id: kinderlight_rgb_light
    initial_state: # This state will be applied when the state is not restored based on restore_mode (below).
      state: on
    restore_mode: RESTORE_DEFAULT_OFF
    default_transition_length: 1s
    effects:
      - strobe: # to identify the object
      - pulse:
          name: "Night Fade"
          transition_length: 2s
          update_interval: 3s
          min_brightness: 10%
          max_brightness: 70%
  - platform: esp32_rmt_led_strip
    rgb_order: GBR  # Or GRB, depending on your LED
    pin: GPIO8
    num_leds: 1
    chipset: WS2812
    id: status_led
    name: "Embedded RGB Light"
    icon: "mdi:led-outline"
    default_transition_length: 0.25s
    effects:
      - random:
      - flicker:
      - addressable_rainbow:

number:
  - platform: template
    name: "Set Red %"
    min_value: 0
    max_value: 100
    initial_value: 100 # default on first boot
    step: 1
    optimistic: true
    mode: BOX # show a textbox, not a slider
    on_value:
      then:
        - light.turn_on:
            id: kinderlight_rgb_light
            # Convert 0-100 to 0.0-1.0
            red: !lambda 'return x / 100.0;'
            # We must preserve the other current colors
            green: !lambda 'return id(kinderlight_rgb_light).remote_values.get_green();'
            blue: !lambda 'return id(kinderlight_rgb_light).remote_values.get_blue();'

  - platform: template
    name: "Set Green %"
    min_value: 0
    max_value: 100
    initial_value: 100 # default on first boot
    step: 1
    optimistic: true
    mode: BOX # show a textbox, not a slider
    on_value:
      then:
        - light.turn_on:
            id: kinderlight_rgb_light
            green: !lambda 'return x / 100.0;'
            red: !lambda 'return id(kinderlight_rgb_light).remote_values.get_red();'
            blue: !lambda 'return id(kinderlight_rgb_light).remote_values.get_blue();'

  - platform: template
    name: "Set Blue %"
    min_value: 0
    max_value: 100
    initial_value: 100 # default on first boot
    step: 1
    optimistic: true
    mode: BOX # show a textbox, not a slider
    on_value:
      then:
        - light.turn_on:
            id: kinderlight_rgb_light
            blue: !lambda 'return x / 100.0;'
            red: !lambda 'return id(kinderlight_rgb_light).remote_values.get_red();'
            green: !lambda 'return id(kinderlight_rgb_light).remote_values.get_green();'

  - platform: template
    name: "Darkness Threshold"
    id: dark_threshold
    optimistic: true
    restore_value: true         # save in flash and restore on reboot
    min_value: 0
    max_value: 50 # max value for the slider
    step: 0.1
    unit_of_measurement: "lx"
    initial_value: 20           # default on first boot
    #mode: BOX # show a textbox, not a slider

# Binary sensor to detect darkness
binary_sensor:
  - platform: template
    name: "KinderLight Is Dark"
    id: is_dark
    device_class: light
    lambda: |-
      // Compare the calculated REAL lux with the threshold
      return id(real_lux_sensor).state < id(dark_threshold).state;

interval:
  - interval: 5s
    then:
      - lambda: |-
          // Log BH1750 I2C status
          if (!id(ambient_light).has_state()) {
            ESP_LOGW("i2c", "BH1750 sensor missing or not responding.");
          }
  # target value: 3s?
  - interval: 1s
    then:
      - if:
          #
          condition:
            and:
              # is dark
              - binary_sensor.is_on: is_dark
              # no override
              - switch.is_off: manual_override
              # currently off
              - light.is_off: kinderlight_rgb_light
          then:
            - light.turn_on:
                id: kinderlight_rgb_light
                transition_length: 1s
          else:
            - if:
                # no override, not dark
                condition:
                  and:
                    - binary_sensor.is_off: is_dark
                    - switch.is_off: manual_override
                    # currently on
                    - light.is_on: kinderlight_rgb_light
                then:
                  - light.turn_off:
                      id: kinderlight_rgb_light
                      transition_length: 1s

switch:
  - platform: template
    name: "KinderLight Manual Override"
    id: manual_override
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF

# (Optional) Voltage input monitoring
# If you connect battery or input voltage monitoring
# Uncomment below if needed
#  - platform: adc
#    pin: GPIO36
#    name: "Input Voltage"
#    attenuation: 11db

text_sensor:
  - platform: version
    name: "KinderLight ESPHome Version"
    icon: mdi:information
    hide_timestamp: true
  - platform: wifi_info
    ip_address:
      name: "KinderLight IP Address"
    mac_address:
      name: "KinderLight MAC Address"
  - platform: template
    name: "KinderLight Hostname"
    id: kl_hostname_ts
    icon: mdi:network
    entity_category: "diagnostic"
    update_interval: 60s
    # framework esp-idf dependant
    lambda: |-
      const char *hostname;
      esp_netif_get_hostname(esp_netif_get_handle_from_ifkey("WIFI_STA_DEF"), &hostname);
      return std::string(hostname);

  - platform: template
    name: "RGB Light Debug"
    id: rgb_debug_info
    icon: "mdi:bug"
    entity_category: "diagnostic"
    update_interval: 5s
    lambda: |-
      char buffer[120];

      // 1. Get the current active values from the Light Component
      // "current_values" shows the live state (even during fades)
      auto values = id(kinderlight_rgb_light).current_values;

      std::string state = values.is_on() ? "ON" : "OFF";
      float bri = values.get_brightness();

      // 2. Get the Color Channels (0.0 to 1.0)
      float r_color = values.get_red();
      float g_color = values.get_green();
      float b_color = values.get_blue();

      // 3. Calculate the actual PWM (Duty Cycle)
      // The pin receives: Color * Brightness
      float r_pwm = r_color * bri;
      float g_pwm = g_color * bri;
      float b_pwm = b_color * bri;

      // 4. Format into a readable string
      sprintf(buffer, "State: %s | Bri: %.0f%% | PWM-> R:%.0f%% G:%.0f%% B:%.0f%%",
              state.c_str(), (bri * 100.0), (r_pwm * 100.0), (g_pwm * 100.0), (b_pwm * 100.0));

      return {buffer};

  - platform: template
    name: "KinderLight Live Calc"
    icon: "mdi:calculator-variant"
    entity_category: "diagnostic"
    update_interval: 2s
    lambda: |-
      char buffer[100];
      float raw = id(ambient_light).state;
      float real = id(real_lux_sensor).state;
      float offset = raw - real; // Derive offset from the difference

      sprintf(buffer, "Raw: %.1f | Off: -%.1f | Real: %.1f", raw, offset, real);
      return {buffer};

time:
  - platform: sntp
    id: sntp_time
    timezone: "Europe/Rome"
    # No servers defined = use DHCP provided servers
#    on_time:
#      - hours: 21
#        minutes: 0
#        then:
#          - light.control:
#              id: kinderlight_rgb_light
#              red: 100%
#              green: 0%
#              blue: 0%
#    # At 7:00 AM - Set internal state to Warm White/Amber
#      - hours: 7
#        minutes: 0
#        then:
#          - light.control:
#              id: kinderlight_rgb_light
#              red: 100%
#              green: 80%
#              blue: 40%
